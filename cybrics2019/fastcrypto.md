# Fast-Crypto

We have a .wav, which is XOR'ed with some generated byte-stream.
The stream depends on a power (2-16) and a seed (0-2**16). 
That leaves about 1M possibilities, which is few enough for brute force.
However, encryption is very slow, so we have to speed it up.

* `get_next` should use modular exponentiation `pow(a, power, N)`
* The loop for iterated power can be turned into one: `pow(a, power**31337, N)`
* We can factor N to compute phi(N) and use Euler's Theorem: `pow(a, (power**31337) % phi(N), N)`
* A .wav begins with `RIFF` as signature, so we just check the first 4 Byte. If they do not match, try the next combination.

Running brute force yields the decoded file (in my case about 20 minutes).
Then just listen to the flag.
